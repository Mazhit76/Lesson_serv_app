
# 1. Каждое из слов «разработка», «сокет», «декоратор» представить в строковом формате и проверить тип и содержание соответствующих переменных.
# Затем с помощью онлайн-конвертера преобразовать строковые представление в формат Unicode и также проверить тип и содержимое переменных.

my_str = ['разработка', 'сокет', 'декоратор']
# Unicod - это преобразованнный в предсnтвление посредством  ord() каждого символа для того чтобы можно было
# использовать не толко 128 или 256 символов а гораздо больше
# и затем переведенную в байтовое представление, например  b'' или hex()- перевод в шестнадцатеричную систему счисления

# При печпти всегда выводит в строковом представлении в Python 3.0 и выше Unicod  и str это одно и тот же тип
my_str_unic = ['\u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u043a\u0430', '\u0441\u043e\u043a\u0435\u0442',
               '\u0434\u0435\u043a\u043e\u0440\u0430\u0442\u043e\u0440']

for i in my_str:
    print(f'{type(i)}   {i}')
for i in my_str_unic:
    print(f'Unicod_____________{type(i)}   {i}')



# 2. Каждое из слов «class», «function», «method» записать в байтовом типе без преобразования в последовательность кодов
# (не используя методы encode и decode) и определить тип, содержимое и длину соответствующих переменных.

mas = [b'class', b'function', b'method']

for i in mas:
    print(f'{type(i)}  {i}   {len(i)}')



# 3. Определить, какие из слов «attribute», «класс», «функция», «type» невозможно записать в байтовом типе.

# print(b'класс')---выдаст ошибку потому что перед тем как кириллицу преобразовать в байты необходимо вначале в юникод преробразовать

# 4. Преобразовать слова «разработка», «администрирование», «protocol», «standard» из строкового представления в
# байтовое и выполнить обратное преобразование (используя методы encode и decode).

mas_p = ['разработка', 'protocol', 'protocol', 'standard']
mas_b = list(map(lambda x: x.encode('utf-8'), mas_p))
print(mas_b)
mas_str = list(map(lambda x: x.decode('utf-8'), mas_b))
print(mas_str)




# 5. Выполнить пинг веб-ресурсов yandex.ru, youtube.com и преобразовать результаты из байтовового в строковый тип на кириллице.

#
# # результат работы модуля subprocess при проверке качества подключения по сети(команда ping)
# import subprocess
# # модуль subprocess
#
# args_mas = [['ping', 'youtube.com'], ['ping', 'google.com']]
# for args in args_mas:
#     subproc_ping = subprocess.Popen(args, stdout=subprocess.PIPE)
#     for line in subproc_ping.stdout:
#         # выводим результат в байтах
#         print(line)
#         # изменяем кодировку результата
#         line = line.decode('cp866').encode('utf-8')
#         # выводи результат в кодировке utf-8
#         print(line.decode('utf-8'))




# 6. Создать текстовый файл test_file.txt, заполнить его тремя строками: «сетевое программирование», «сокет», «декоратор».
# Проверить кодировку файла по умолчанию. Принудительно открыть файл в формате Unicode и вывести его содержимое.


import  locale

def_coding = locale.getpreferredencoding()
print(def_coding)


# получаем кодировку для файла, с которым работаем
f_n = open("test.txt", "w")
f_n.write("test test test 54")
f_n.close()
print(f_n)

with open('test.txt', encoding='utf-8') as f_out:
    for el in f_out:
        print(el, end='')